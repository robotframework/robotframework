Creating test libraries
-----------------------

Robot Framework's actual testing capabilities are provided by test
libraries. There are many existing libraries, some of which are even
bundled with the core framework, but there is still often a need to
create new ones. This task is not too complicated because, as this
chapter illustrates, Robot Framework's library API is simple
and straightforward.

.. contents::
   :depth: 2 
   :local: 


Introduction
~~~~~~~~~~~~

Supported programming languages
'''''''''''''''''''''''''''''''

Robot Framework itself is written with Python_ and naturally test
libraries extending it can be implemented using the same
language. When running the framework on Jython_, libraries can also be
implemented using Java_. Pure Python code works both on Python and
Jython, assuming that it does not use syntax or modules that are not
available on Jython. When using Python, it is also possible to
implement libraries with C using `Python C API`__, although it is
often easier to interact with C code from Python libraries using
ctypes__ module.

Libraries implemented using these natively supported languages can
also act as wrappers to functionality implemented using other
programming languages. A good example of this approach is the `Remote
library`_, and another widely used approaches is running external
scripts or tools as separate processes.

__ http://docs.python.org/c-api/index.html
__ http://docs.python.org/library/ctypes.html

Different test library APIs
'''''''''''''''''''''''''''

Robot Framework has three different test library APIs. 

Static API 

  The simplest approach is having a module (in Python) or a class
  (in Python or Java) with methods the names of which map more or less
  directly to `keyword names`_. Keywords also take the same `arguments`__ as
  the code implementing them.  Keywords `report failures`__ with
  exceptions, `log`__ by writing to standard output and can `return
  values`__ using the :code:`return` statement.

Dynamic API

  Dynamic libraries are classes that implement a method to get the names
  of the keywords they implement, and another method to execute a named 
  keyword with given arguments. The names of the keywords to implement, as
  well as how they are executed, can be determined dynamically at
  runtime, but reporting the status, logging and returning values is done
  similarly as in the static API.

Hybrid API

  This is a hybrid between the static and the dynamic API. Libraries are
  classes with a method telling what keywords they implement, but
  those keywords must be available directly. Everything else except
  discovering what keywords are implemented is similar as in the
  static API.
  
All these APIs are described in this chapter. Everything is based on
how the static API works, so its functions are discussed first. How
the `dynamic library API`_ and the `hybrid library API`_ differ from it
is then discussed in sections of their own.

The examples in this chapter are mainly about using Python, but they
should be easy to understand also for Java-only developers. In those
few cases where APIs have differences, both usages are explained with
adequate examples.

__ `Keyword arguments`_
__ `Reporting keyword status`_
__ `Logging information`_
__ `Returning values`_


Creating test library class or module
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Test libraries can be implemented as Python modules or Python or Java classes. 
In Robot Framework 2.0.1 and earlier, it is possible to use only classic
classes as test libraries. Both classic and new style classes are 
supported from 2.0.2 onwards.

Test library names
''''''''''''''''''

The name of a test library that is used when a library is imported is
the same as the name of the module or class implementing it. For
example, if you have a Python module :code:`MyLibrary` (that is, the
file :path:`MyLibrary.py`), it will create a library with a name
:name:`MyLibrary`. Similarly, a Java class :code:`YourLibrary`, when
it is not in any package, creates a library with exactly that name.

Python classes are always inside a module. If the name of a class
implementing a library is the same as the name of the module, Robot
Framework allows dropping the module name when importing the
library. For example, the class :code:`MyLib` in the :path:`MyLib.py`
file can be used as a library with the name :name:`MyLib`. If the
module name and class name are different, libraries must be taken into
use using both module and class names, such as
:name:`mymodule.MyLibrary`.

Java classes in a non-default package must be taken into use with the
full name. For example, the class :code:`MyLib` in the
:code:`com.mycompany.myproject` package must be imported with the name
:name:`com.mycompany.myproject.MyLib`.

.. Tip:: If the library name is really long, for example when the Java
         package name is long, it is recommended to give the library a
         simpler alias by using the `WITH NAME syntax`_.

Providing arguments to test libraries
'''''''''''''''''''''''''''''''''''''

All test libraries implemented as classes can take arguments. These
arguments are specified in the Setting table after the library name,
and when Robot Framework creates an instance of the imported library,
it passes them to its constructor. Libraries implemented as a module
cannot take any arguments, so trying to use those results in an error.

The number of arguments needed by the library is the same
as the number of arguments accepted by the library's
constructor. The default values and variable number of arguments work
similarly as with `keyword arguments`_, with the exception that there
is no variable argument support for Java libraries. Arguments passed
to the library, as well as the library name itself, can be specified
using variables, so it is possible to alter them, for example, from the command
line.

.. table:: Importing a test library with arguments
   :class: example

   =========  ===========  =========  =======
    Setting      Value       Value     Value
   =========  ===========  =========  =======
   Library    MyLibrary    10.0.0.1   8080
   Library    AnotherLib   ${VAR}     \
   =========  ===========  =========  =======

Example implementations, first one in Python and second in Java, for
the libraries used in the above example:

.. sourcecode:: python

  from example import Connection

  class MyLibrary:

      def __init__(self, host, port=80):
          self._conn = Connection(host, int(port))

      def send_message(self, message):
          self._conn.send(message)

.. sourcecode:: java

   public class AnotherLib {

       private String setting = null;

       public AnotherLib(String setting) {
           setting = setting;
       }

       public void doSomething() {
           if setting.equals("42") {
               // do something ...
           }
       }
   }

Test library scope
''''''''''''''''''

Libraries implemented as classes can have an internal state, which can
be altered by keywords and with arguments to the constructor of the
library. Because the state can affect how keywords actually behave, it
is important to make sure that changes in one test case do not
accidentally affect other test cases. This kind of dependencies may
create hard-to-debug problems, for example, when new test cases are
added and they use the library inconsistently.

Robot Framework attempts to keep test cases independent from each
other: by default, it creates new instances of test libraries for
every test case. However, this behavior is not always desirable,
because sometimes test cases should be able to share a common
state. Additionally, all libraries do not have a state and creating
new instances of them is simply not needed.

Test libraries can control when new libraries are created with a
class attribute :code:`ROBOT_LIBRARY_SCOPE` . This attribute must be
a string and it can have the following three values:

`TEST CASE`:code:
  A new instance is created for every test case. A possible suite setup
  and suite teardown share yet another instance. This is the default.

`TEST SUITE`:code:
  A new instance is created for every test suite. The lowest-level test
  suites, created from test case files and containing test cases, have
  instances of their own, and higher-level suites all get their own instances
  for their possible setups and teardowns.

`GLOBAL`:code: 
  Only one instance is created during the whole test execution and it
  is shared by all test cases and test suites. Libraries created from
  modules are always global.

When the :code:`TEST SUITE` or :code:`GLOBAL` scopes are used with test
libraries that have a state, it is recommended that libraries have some
special keyword for cleaning up the state. This keyword can then be
used, for example, in a suite setup or teardown to ensure that test
cases in the next test suites can start from a known state. For example,
:name:`SeleniumLibrary` uses the :code:`GLOBAL` scope to enable
using the same browser in different test cases without having to
reopen it, and it also has the :name:`Close All Browsers` keyword for
easily closing all open browsers.

Example Python library using the :code:`TEST SUITE` scope:

.. sourcecode:: python

    class ExampleLibrary:

        ROBOT_LIBRARY_SCOPE = 'TEST SUITE'

        def __init__(self):
            self._counter = 0
  
        def count(self):
            self._counter += 1
            print self._counter

        def clear_counter(self):
            self._counter = 0

Example Java library using the :code:`GLOBAL` scope:

.. sourcecode:: java

    public class ExampleLibrary {

        public static final String ROBOT_LIBRARY_SCOPE = "GLOBAL";

        private int counter = 0;

        public void count() {
            counter += 1;
            System.out.println(counter);
        }

        public void clearCounter() {
            counter = 0;
        }
    }

Specifying library version
''''''''''''''''''''''''''

When a test library is taken into use, Robot Framework tries to
determine its version. This information is then written into the syslog_
to provide debugging information. Library documentation tool
`libdoc.py`_ also writes this information into the keyword
documentations it generates.

Version information is read from attribute
:code:`ROBOT_LIBRARY_VERSION`, similarly as `test library scope`_ is
read from :code:`ROBOT_LIBRARY_SCOPE`. If
:code:`ROBOT_LIBRARY_VERSION` does not exist, information is tried to
be read from :code:`__version__` attribute. These attributes must be a
class or module attributes, depending whether the library is
implemented as a class or a module.  For Java libraries, the version
attribute must be declared as :code:`static final`.

An example Python module using :code:`__version__`:

.. sourcecode:: python

    __version__ = '0.1'

    def keyword():
        pass

A Java class using :code:`ROBOT_LIBRARY_VERSION`:

.. sourcecode:: java

    public class VersionExample {
        
        public static final String ROBOT_LIBRARY_VERSION = "1.0.2";
        
        public void keyword() {
        }
    }


Creating static keywords
~~~~~~~~~~~~~~~~~~~~~~~~

Keyword names
'''''''''''''

When the static library API is used, Robot Framework uses reflection
to find out what methods the library implements. With `dynamic library
API`_ and `hybrid library API`_, keyword names are got from the
library directly. Naturally, Robot Framework can see only the public
methods and it also excludes all methods starting with an
underscore. With Java libraries, also methods that are implemented in
:code:`java.lang.Object` and not overridden are ignored.

Keyword names used in the test data are compared with method names to
find the method implementing these keywords. Name comparison is
case-insensitive, and also spaces and underscores are ignored. For
example, the method :code:`hello` maps to the keyword name
:name:`Hello`, :name:`hello` or even :name:`h e l l o`. Similarly both the
:code:`do_nothing` and :code:`doNothing` methods can be used as the
:name:`Do Nothing` keyword in the test data.

Example Python library implemented as a module in the :path:`MyLibrary.py` file:

.. sourcecode:: python

  def hello(name):
      print "Hello, %s!" % name

  def do_nothing():
      pass

Example Java library implemented as a class in the :path:`MyLibrary.java` file:

.. sourcecode:: java

  public class MyLibrary {

      public void hello(String name) {
          System.out.println("Hello, " + name + "!");
      }

      public void doNothing() { 
      }

  }

The example below illustrates how the example libraries above can be
used. If you want to try this yourself, make sure that the library is
in the `library search path`_. Note that in the subsequent examples all
boilerplates, such as taking a library into use and creating a test
case, is excluded.

.. table:: Using simple example library
   :class: example  

   =========  ===========  =======  =======
    Setting      Value      Value    Value
   =========  ===========  =======  =======
   Library     MyLibrary   \        \
   =========  ===========  =======  =======

.. table::
   :class: example

   ===========  ===========  ============  ============
    Test Case     Action       Argument      Argument
   ===========  ===========  ============  ============
   My Test      Do Nothing   \             \
   \            Hello        world         \
   ===========  ===========  ============  ============

Keyword arguments
'''''''''''''''''

With a static and hybrid API, the information on how many arguments a
keyword needs is got directly from the method that implements it.
Libraries using the `dynamic library API`_ have other means for getting
this information, so this section is not relevant to them.

The most common and also simplest situation is when a keyword needs an
exact number of arguments. In this case, both the Python and Java methods
simply take exactly those arguments. For example, a method implementing a
keyword with no arguments takes no arguments either, a method
implementing a keyword with one argument also takes one argument, and
so on.

Example Python keywords taking different numbers of arguments:

.. sourcecode:: python

  def no_arguments():
      print "Keyword got no arguments"

  def one_argument(arg):
      print "Keyword got one argument '%s'" % arg

  def multiple_arguments(a1, a2, a3):
      print "Keyword got three arguments '%s', '%s' and '%s'" % (a1, a2, a3)

Default values to keywords
''''''''''''''''''''''''''

It is often useful that some of the arguments that a keyword uses have
default values. Python and Java have different syntax for handling default
values to methods, and the natural syntax of these languages can be
used when creating test libraries for Robot Framework.

Default values with Python
``````````````````````````
In Python a method has always exactly one implementation and possible
default values are specified in the method signature. The syntax,
which is familiar to all Python programmers, is illustrated below:

.. sourcecode:: python

   def one_default(arg='default'):
       print "Argument has value '%s'" % arg

   def multiple_defaults(arg1, arg2='default 1', arg3='default 2'):
       print "Got arguments %s, %s and %s" % (arg1, arg2, arg3)

The first example keyword above can be used either with zero or one
arguments. If no arguments are given, :code:`arg` gets the value
:code:`default`. If there is one argument, :code:`arg` gets that value,
and calling the keyword with any other number of arguments fails. In the
second example, one argument is always required, but the second and
the third one have default values, so it is possible to use the keyword
with one to three arguments.

.. table:: Using keywords with variable number of arguments
   :class: example

   ===========  ==================  =============  ============  =============
    Test Case         Action          Argument       Argument       Argument 
   ===========  ==================  =============  ============  =============
   Defaults     One Default         \              \             \
   \            One Default         argument       \             \
   \            Multiple Defaults   required arg   \             \
   \            Multiple Defaults   required arg   optional      \
   \            Multiple Defaults   required arg   optional 1    optional 2
   ===========  ==================  =============  ============  =============

Default values with Java
````````````````````````
In Java one method can have several implementations with different
signatures. Robot Framework regards all these implementations as one
keyword, which can be used with different arguments. This syntax can
thus be used to provide support for the default values. This is
illustrated by the example below, which is functionally identical to
the earlier Python example:

.. sourcecode:: java
  
   public void oneDefault(String arg) {
       System.out.println("Argument has value '" + arg "'");
   }

   public void oneDefault() {
       oneDefault("default");
   }

   public void multipleDefaults(String arg1, String arg2, String arg3) {
       System.out.println("Got arguments " + arg1 + ", " + arg2 + " and " + arg3);
   }

   public void multipleDefaults(String arg1, String arg2) {
       multipleDefaults(arg1, arg2, "default 2");
   }

   public void multipleDefaults(String arg1) {
       multipleDefaults(arg1, "default 1");
   }

Variable number of arguments
''''''''''''''''''''''''''''

Robot Framework supports also keywords that take any number of
arguments. Similarly as with the default values, the actual syntax to use
in test libraries is different in Python and Java.

Variable number of arguments with Python
````````````````````````````````````````
Python itself has a good support for methods accepting any
number of arguments. The same syntax works in libraries and, as
the examples below show, it can also be combined with other ways of
specifying arguments:

.. sourcecode:: python

  def any_arguments(*args):
      print "Got arguments:"
      for arg in args:
          print arg

  def one_required(required, *others):
      print "Required: %s\nOthers:" % required
      for arg in others:
          print arg

  def also_defaults(req, def1="default 1", def2="default 2", *rest):
      print req, def1, def2, rest

.. table:: Using keywords with a variable number of arguments
   :class: example

   ===========  ==============  =============  ============  ==============
    Test Case       Action         Argument      Argument       Argument 
   ===========  ==============  =============  ============  ==============
   Varargs      Any Arguments   \              \             \
   \            Any Arguments   argument       \             \
   \            Any Arguments   arg 1          arg 2         arg 2
   \            ...             arg 4          arg 5         \
   \            One Required    required arg   \             \
   \            One Required    required arg   another arg   yet another
   \            Also Defaults   required       \             \
   \            Also Defaults   required       these two     have defaults 
   \            Also Defaults   1              2             3
   \            ...             4              5             6
   ===========  ==============  =============  ============  ==============

Variable number of arguments with Java
``````````````````````````````````````
In Java, there is no syntax for a variable number of arguments, but Robot
Framework has its own support for them. If the last argument in a keyword
signature is an array, all leftover arguments are packed into
it. This also works, if the keyword is used with one argument less than
the actual number of arguments in the signature - in this case the
array at the end will be empty. 

This system has one limitation: it only works if the method has one
signature. Thus it is not possible to have a Java keyword that has
both the default values and a variable number of arguments. Of course,
having the required values with a variable number of arguments is
possible, as the examples below illustrate:

.. sourcecode:: java

  public void anyArguments(String[] args) {
      System.out.println("Got arguments:");
      for (int i; i < args.length; i++) {
          System.out.println(args[i]);
      }
  }

  public void oneRequired(String required, String[] others) {
      System.out.println("Required: " + required + "\nOthers:");
      for (int i; i < others.length; i++) {
          System.out.println(others[i]);
      }
  }

Argument types
''''''''''''''

Normally keyword arguments come to Robot Framework as strings. If
keywords require some other types, it is possible to either use
variables_ or convert strings to required types inside keywords. With
`Java keywords`__ base types are also coerced automatically.

__ `Argument types with Java`_

Argument types with Python
``````````````````````````
Because arguments in Python do not have any type information, there is
no possibility to automatically convert strings to other types when
using Python libraries. Calling a Python method implementing a keyword
with a correct number of arguments always succeeds, but the execution
fails later if the arguments are incompatible. Luckily with Python it
is simple to convert arguments to suitable types inside keywords:

.. sourcecode:: python

  def connect_to_host(address, port=25):
      port = int(port)
      # ...

Argument types with Java
````````````````````````
Arguments to Java methods have types, and starting from Robot
Framework 2.1 all the base types are handled automatically. This
means that arguments that are normal strings in the test data are
coerced to correct type at runtime. The types that can be coerced
are:

- integer types (:code:`byte`, :code:`short`, :code:`int`, :code:`long`)
- floating point types (:code:`float` and :code:`double`)
- the :code:`boolean` type
- object versions of the above types e.g. :code:`java.lang.Integer`

The coercion is done for arguments that have the same or compatible
type across all the signatures of the keyword method. In the following
example, the conversion can be done for keywords :code:`doubleArgument`
and :code:`compatibleTypes`, but not for :code:`conflictingTypes`.

.. sourcecode:: java
  
   public void doubleArgument(double arg) {}

   public void compatibleTypes(String arg1, Integer arg2) {}
   public void compatibleTypes(String arg2, Integer arg2, Boolean arg3) {}

   public void conflictingTypes(String arg1, int arg2) {}
   public void conflictingTypes(int arg1, String arg2) {}

The coercion works with the numeric types if the test data has a
string containing a number, and with the boolean type the data must
contain either string :code:`true` or :code:`false`. Coercion is only
done if the original value was a string from the test data, but it is
of course still possible to use variables containing correct types with
these keywords. With keywords having conflicting signatures using
variables is the only option.

.. table:: Using automatic type coercion
   :class: example

   ===========  =================  =============  ==========  =====================
    Test Case         Action          Argument     Argument        Argument 
   ===========  =================  =============  ==========  =====================
   Coercion     Double Argument    3.14
   \            Double Argument    2e16                       # scientific notation
   \            Compatible Types   Hello, world!  1234          
   \            Compatible Types   Hi again!      -10         true
   \
   No Coercion  Double Argument    ${3.14}                         
   \            Conflicting Types  1              ${2}        # must use variables
   \            Conflicting Types  ${1}           2              
   ===========  =================  =============  ==========  =====================


Communicating with Robot Framework
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

After a method implementing a keyword is called, it can use any
mechanism to communicate with the system under test. It can then also
send messages to Robot Framework's log file, return information that
can be saved to variables and, most importantly, report if the
keyword passed or not. 

Reporting keyword status
''''''''''''''''''''''''

Reporting keyword status is done simply using exceptions. If an executed
method raises an exception, the keyword status is :msg:`FAIL`, and if it
returns normally, the status is :msg:`PASS`.

The error message shown in logs, reports and the console is created
from the exception type and its message. With generic exceptions (for
example, :code:`AssertionError`, :code:`Exception`, and
:code:`RuntimeError`), only the exception message is used, and with
others, the message is created in the format :msg:`ExceptionType:
Actual message`. In both cases, it is important for the users that the
exception message is as informative as possible.

If the error message is longer than 20 lines, it will be automatically
cut from the middle to prevent reports from getting too long and
difficult to read. The full error message is always shown in the log
message of the failed keyword.

The traceback of the exception is also logged using :msg:`DEBUG` `log level`_.
These messages are not visible in log files by default because they are very
rarely interesting for normal users. When developing libraries, it is often a
good idea to run tests using :cli:`--loglevel DEBUG`. Notice that in Robot
Framework 2.0.2 and earlier the log level for tracebacks was :msg:`INFO`.

Logging information
'''''''''''''''''''

Exception messages are not the only way to give information to the
users. In addition to that, methods can also send messages to `log
files`_ simply by writing to standard output (stdout) or standard
error (stderr), and they can even use different `log levels`_.

By default, everything written by a method to stdout is written into a
log file as a single entry with the log level
:msg:`INFO`. Messages written into stderr are handled similarly
otherwise, but they are echoed back to the original stderr after the
keyword execution has finished.

To use other log levels than :msg:`INFO`, or to create several
messages, specify the log level explicitly by embedding the level into
the message in the format :msg:`*LEVEL* Actual log message`, where
:msg:`*LEVEL*` must be in the beginning of a line and :msg:`LEVEL` is
one of the available logging levels :msg:`TRACE`, :msg:`DEBUG`,
:msg:`INFO`, :msg:`WARN` and :msg:`HTML`.

Warnings
````````
Starting from Robot Framework 2.1 messages with :msg:`WARN` level are
automatically written into `the console and into separate Test Execution
Errors section`__ in log files. This makes warnings more visible than
other messages and allows using them for reporting important but 
non-critical problems to users.

__ `Errors and warnings during execution`_

Logging HTML
````````````
Everything normally logged by the library will be converted into a
format that can be safely represented as HTML. For example,
:code:`<b>foo</b>` will be displayed in the log exactly like that and
not as **foo**. If libraries want to use formatting, links, display
images and so on, they can use a special pseudo log level
:msg:`HTML`. Robot Framework will write these messages directly into
the log with the :msg:`INFO` level, so they can use any HTML syntax
they want. Notice that this feature needs to be used with care, because
one badly placed :code:`</table>` tag can ruin the log file quite
badly.

Logging example
```````````````
In most cases, the :msg:`INFO` level is adequate. The levels below it,
:msg:`DEBUG` and :msg:`TRACE`, are useful for writing debug information.
These messages are normally not shown, but they can facilitate debugging
possible problems in the library itself. The :msg:`WARN` level can
be used to make messages more visible and :msg:`HTML` is useful if any 
kind of formatting is needed.

The following examples clarify how logging with different levels
works. Java programmers should regard the code :code:`print 'message'`
as pseudocode meaning :code:`System.out.println("message");`.

.. sourcecode:: python

   print 'Hello from a library.'
   print '*WARN* Warning from a library.'
   print '*INFO* Hello again!'
   print 'This will be part of the previous message.'
   print '*INFO* This is a new message.'
   print '*INFO* This is <b>normal text</b>.'
   print '*HTML* This is <b>bold</b>.'
   print '*HTML* <a href="http://robotframework.org">Robot Framework</a>'

.. raw:: html

   <table class="messages">
     <tr>
       <td class="time">16:18:42.123</td>
       <td class="info level">INFO</td>
       <td class="msg">Hello from a library.</td>
     </tr>
     <tr>
       <td class="time">16:18:42.123</td>
       <td class="warn level">WARN</td>
       <td class="msg">Warning from a library.</td>
     </tr>
     <tr>
       <td class="time">16:18:42.123</td>
       <td class="info level">INFO</td>
       <td class="msg">Hello again!<br>This will be part of the previous message.</td>
     </tr>
     <tr>
       <td class="time">16:18:42.123</td>
       <td class="info level">INFO</td>
       <td class="msg">This is a new message.</td>
     </tr>
     <tr>
       <td class="time">16:18:42.123</td>
       <td class="info level">INFO</td>
       <td class="msg">This is &lt;b&gt;normal text&lt;/b&gt;.</td>
     </tr>
     <tr>
       <td class="time">16:18:42.123</td>
       <td class="info level">INFO</td>
       <td class="msg">This is <b>bold</b>.</td>
     </tr>
     <tr>
       <td class="time">16:18:42.123</td>
       <td class="info level">INFO</td>
       <td class="msg"><a href="http://robotframework.org">Robot Framework</a></td>
     </tr>
   </table>

Returning values
''''''''''''''''

The final way for keywords to communicate back to the core framework
is returning information retrieved from the system under test or
generated by some other means. The returned values can be `assigned to
variables`__ in the test data and then used as inputs for other keywords,
even from different test libraries. 

Values are returned using the :code:`return` statement both from
the Python and Java methods. Normally, one value is assigned into one
`scalar variable`__, as illustrated in the example below. This example
also illustrates that it is possible to return any objects and to use
`extended variable syntax`_ to access object attributes.

__ `Return values from keywords`_
__ `Scalar variables`_

.. sourcecode:: python

  from mymodule import MyObject

  def return_string():
      return "Hello, world!"

  def return_object(name):
      return MyObject(name)

.. table:: Return one value from keywords
   :class: example

   ================  ===============  ==============
   ${string} =       Return String    \            
   Should Be Equal   ${string}        Hello, world!
   ${object} =       Return Object    Robot        
   Should Be Equal   ${object.name}   Robot        
   ================  ===============  ==============

Keywords can also return values so that they can be assigned into
several `scalar variables`_ at once, into `a list variable`__, or
into scalar variables and a list variable. All these usages require
that returned values are Python lists or tuples or
Java arrays. If there is a need, support for other iterables can be
added in the future.

__ `List variables`_

.. sourcecode:: python

  def return_two_values():
      return 'first value', 'second value'

  def return_multiple_values():
      return ['a', 'list', 'of', 'strings']


.. table:: Returning multiple values
   :class: example

   ================  ==================  ==================  =======================
   ${var1}           ${var2} =           Return Two Values   \
   Should Be Equal   ${var1}             first value         \
   Should Be Equal   ${var2}             second value        \
   @{list} =         Return Two Values   \                   \
   Should Be Equal   @{list}[0]          first value         \
   Should Be Equal   @{list}[1]          second value        \
   ${s1}             ${s2}               @{li} =             Return Multiple Values
   Should Be Equal   ${v1} ${v2}         a list              \
   Should Be Equal   @{li}[0] @{li}[1]   of strings          \
   ================  ==================  ==================  =======================


Distributing test libraries
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Documenting libraries
'''''''''''''''''''''

A test library without documentation about what keywords it
contains and what those keywords do is rather useless. To ease
maintenance, it is highly recommended that library documentation is
included in the source code and generated from it. Basically, that
means using docstrings_ with Python and Javadoc_ with Java, as in
the examples below.

.. _docstrings: http://www.python.org/dev/peps/pep-0257/
.. _javadoc: http://java.sun.com/j2se/javadoc/writingdoccomments/index.html

.. sourcecode:: python

    class MyLibrary:
        """This is an example library with some documentation."""

        def keyword_with_short_documentation(self, argument):
            """This keyword has only a short documentation"""
            pass

        def keyword_with_longer_documentation(self):
            """First line of the documentation is here.

            Longer documentation continues here and it can contain
            multiple lines or paragraphs.
            """
            pass

.. sourcecode:: java

    /**
     *  This is an example library with some documentation.
     */
    public class MyLibrary {

        /**
         * This keyword has only a short documentation
         */
        public void keywordWithShortDocumentation(String argument) {
        }

        /**
         * First line of the documentation is here.
         *
         * Longer documentation continues here and it can contain
         * multiple lines or paragraphs.
         */
        public void keywordWithLongerDocumentation() {
        }

    }

Both Python and Java have tools for creating an API documentation of a
library documented as above. However, outputs from these tools can be slightly
technical for some users. Another alternative is using Robot
Framework's own documentation tool `libdoc.py`_. This tool can
create a library documentation from both Python and Java libraries
using the static library API, such as the ones above, but it also handles
libraries using the `dynamic library API`_ and `hybrid library API`_.

The first line of a keyword documentation is used for a special
purpose and should contain a short overall description of the
keyword. It is used as a *short documentation*, for example as a tool
tip, by `libdoc.py`_ and also shown in the test logs. However, the latter
does not work with Java libraries using the static API,
because their documentations are lost in compilation and not available
at runtime.

Testing libraries
'''''''''''''''''

Any non-trivial test library needs to be thoroughly tested to prevent
bugs in them. Of course, this testing should be automated to make it
easy to rerun tests when libraries are changed. 

Both Python and Java have excellent unit testing tools, and they suite
very well for testing libraries. There are no major differences in
using them for this purpose compared to using them for some other
testing. The developers familiar with these tools do not need to learn
anything new, and the developers not familiar with them should learn
them anyway.

It is also easy to use Robot Framework itself for testing libraries
and that way have actual end-to-end acceptance tests for them. There are
plenty of useful keywords in the `BuiltIn library`_ for this
purpose. One worth mentioning specifically is :name:`Run Keyword And Expect
Error`, which is useful for testing that keywords report errors
correctly. 

Whether to use a unit- or acceptance-level testing approach depends on
the context. If there is a need to simulate the actual system under
test, it is often easier on the unit level. On the other hand,
acceptance tests ensure that keywords do work through Robot
Framework. If you cannot decide, of course it is possible to use both
the approaches.

Packaging libraries
'''''''''''''''''''

After a library is implemented, documented, and tested, it still needs
to be distributed to the users. With simple libraries consisting of a
single file, it is often enough to ask the users to copy that file
somewhere and set the `library search path`_ accordingly. With more
complicated libraries, package them to make the installation easier.

Since libraries are normal programming code, they can be packaged
using normal packaging tools. With Python, good options include
distutils_, contained by Python's standard library, and the newer
setuptools_. A benefit of these tools is that library modules are
installed into a location that is automatically in the `library
search path`_.

When using Java, it is natural to package libraries into a JAR
archive. The JAR package must be put into the `library search path`_
before running tests, but it is easy to `create a start-up`__ script that
does that automatically.

__ `Creating start-up scripts`_

Deprecating keywords
''''''''''''''''''''

Sometimes there is a need to replace existing keywords with new ones
or remove them altogether. Just informing the users about the change
may not always be enough, and it is more efficient to get warnings at
runtime. Starting from Robot Framework 2.0.2 this is possible by
marking these keywords *deprecated*. This makes it easier to find old
keywords from the test data and remove or replace them.

Keywords are deprecated by starting their documentation with
:code:`*DEPRECATED*`. When these keywords are executed, a warning
containing rest of the `short documentation`__ is written both into
`the console and into separate Test Execution Errors section`__ in log
files.  For example, if following keyword is executed there will be a
warning like shown below in the log file.

.. sourcecode:: python

    def example_keyword(argument):
        """*DEPRECATED* Use keyword `Other Keyword` instead.

        This keyword does something to given `argument` and returns the result.
        """
        return do_something(argument)

.. raw:: html

   <table class="messages">
     <tr>
       <td class="time">20080911&nbsp;16:00:22.650</td>
       <td class="warn level">WARN</td>
       <td class="msg">Keyword 'SomeLibrary.Example Keyword' is deprecated. Use keyword `Other Keyword` instead.</td>
     </tr>
   </table>

This deprecation system works with most test libraries and also with
`user keywords`__.  The only exception are keywords implemented in a
Java test library that uses the `static library interface`__ because
their documentation is not available at runtime. With such keywords,
it possible to use user keywords as wrappers and deprecate them.

There is a plan to implement a tool that can use the deprecation
information for automatically replacing deprecated keywords. The tool
will most likely get the name of the new keyword from the
documentation so that it searches words inside backticks
(:code:`\``). Thus it would find :name:`Other Keyword` from the
earlier example. Note that `libdoc.py`_ also automatically creates
internal links using the same syntax.

__ `Documenting libraries`_
__ `Errors and warnings during execution`_
__ `User keyword name and documentation`_
__ `Creating static keywords`_
 

Dynamic library API
~~~~~~~~~~~~~~~~~~~

The dynamic API is in most ways similar to the static API. For
example, reporting the keyword status, logging and returning values
works exactly the same way. Most importantly, there are no differences
in importing dynamic libraries and using their keywords compared to
other libraries, so you do not even need to know what APIs the
libraries use.

The only difference between static and dynamic libraries is the way
how Robot Framework discovers what keywords the library implements,
what arguments and documentation they have and how those keywords are
actually executed. With the static API, all this is done using
reflection (except for the documentation of Java libraries), but
dynamic libraries have special methods that are used for these
purposes.

One of the benefits of the dynamic API is that you have more
flexibility in organizing your library. With the static API, you have all
keywords in one class (or module), whereas with the dynamic API, you can,
for example, implement each keyword as a separate class, if you
want. This use case is not so important with Python, because
its dynamic capabilities and multi-inheritance already give plenty of
flexibility and the `hybrid library API`_ is usually a better option.

Another major use case for the dynamic API is implementing a library
so that it is only a proxy for an actual library on some other
computer or another JVM. This kind of a proxy library can be very
thin, and because keyword names are got dynamically, there is no
need to update the proxy when new keywords are added into the actual
library.

This section explains how the dynamic API works between Robot
Framework and dynamic libraries. It does not matter for Robot
Framework how these libraries are actually implemented (for example,
how calls to the :code:`run_keyword` method are mapped to a correct
keyword implementation), and many different approaches are
possible. However, if you use Java, you may want to examine
`JavaTools`_ before implementing your own system. This collection of
reusable tools supports several ways of creating keywords, and it is
likely that it already has a mechanism that suites your needs.

Getting keyword names
'''''''''''''''''''''

Dynamic libraries tell what keywords they implement with the
:code:`get_keyword_names` method. The method also has the alias
:code:`getKeywordNames` that is recommended when writing Java. This
method cannot take any arguments, and it must return a list of strings
(in Python) or a string array (in Java) containing the names of the
keywords that the library implements.

If the returned keyword names contain several words, they can be returned
separated with spaces or underscores, or in the camelCase format. For
example, :code:`['first keyword', 'second keyword']`,
:code:`['first_keyword', 'second_keyword']`, and
:code:`['firstKeyword', 'secondKeyword']` would all result in the keywords
:name:`First Keyword` and :name:`Second Keyword`.

Dynamic libraries must always have this method. If it is missing, or
if calling it fails for some reason, the library is considered a
static library, instead.

Running keywords
''''''''''''''''

Dynamic libraries have a special :code:`run_keyword` (alias
:code:`runKeyword`) method for executing their keywords. When a
keyword from a dynamic library is used in the test data, Robot
Framework uses the library's :code:`run_keyword` method to get it
executed. This method takes two arguments. The first argument is a
string containing the name of the keyword to be executed in the same
format as returned by :code:`get_keyword_names`. The second argument is
a list of arguments (an object array in Java) given to the keyword in
the test data.

After the library has got the keyword name and arguments, it can
execute the keyword freely, but it must use the same mechanism to
communicate with the framework as static libraries. This
means using exceptions for reporting keyword status, logging by
writing to the standard output and using the return statement in
:code:`run_keyword` for returning something.

Every dynamic library must have both the :code:`get_keyword_names` and
:code:`run_keyword` methods. The rest of the methods in the dynamic
API are optional, so the example below shows a working (albeit
trivial) dynamic library.

.. sourcecode:: python

   class DynamicExample:

       def get_keyword_names(self):
           return ['first keyword', 'second keyword']

       def run_keyword(self, name, args):
           print "Running keyword %s with arguments %s" % (name, args)

Getting keyword arguments
'''''''''''''''''''''''''

If a dynamic library only implements the :code:`get_keyword_names` and
:code:`run_keyword` methods, Robot Framework does not have any information
about the arguments that the implemented keywords need. For example,
both :name:`First Keyword` and :name:`Second Keyword` in the example above
could be used with any number of arguments. This is problematic,
because most real keywords expect a certain number of keywords, and
under these circumstances they would need to check the argument counts
themselves.

Dynamic libraries can tell Robot Framework what arguments the keywords
that it implements actually expect using
:code:`get_keyword_arguments` (alias :code:`getKeywordArguments`)
method. This method takes the name of a keyword as an argument and returns a
list of strings (a string array in Java) containing the arguments
accepted by that keyword.

Similarly as static keywords, dynamic keywords can require any number
of arguments, have default values and accept a variable number of
arguments. The syntax for how to represent all these different
situations is explained in the following table. Note that the examples
use Python lists of strings, but Java developers should be able to
translate them to string arrays.

.. table:: Representing different arguments with :code:`get_keyword_arguments`
   :class: tabular

   +-----------------+----------------------------+-------------------------------+-------+
   |    Expected     |      How to represent      |            Examples           | Min / |
   |    arguments    |                            |                               | Max   |
   +=================+============================+===============================+=======+
   | No arguments    | Empty list.                | :code:`[]`                    | 0/0   |
   +-----------------+----------------------------+-------------------------------+-------+
   | One or more     | List of strings containing | :code:`['one_argument']`,     | 1/1,  |
   | argument        | argument names.            | :code:`['a1', 'a2', 'a3']`    | 3/3   |
   +-----------------+----------------------------+-------------------------------+-------+
   | Default values  | Default values separated   | :code:`['arg=default value']`,| 0/1,  |
   | for arguments   | from names with :code:`=`. | :code:`['a', 'b=1', 'c=2']`   | 1/3   |
   |                 | Default values are always  |                               |       |
   |                 | considered to be strings.  |                               |       |
   +-----------------+----------------------------+-------------------------------+-------+
   | Variable number | Last argument has          | :code:`['*arguments']`,       | 0/any,|
   | of arguments    | :code:`*` before its name. | :code:`['a', 'b=42', '*rest']`| 1/any |
   +-----------------+----------------------------+-------------------------------+-------+

When the :code:`get_keyword_arguments` is used, Robot Framework
automatically calculates how many arguments the keywords require. If a
keyword is used with an invalid number of arguments, an error occurs
and :code:`run_keyword` is not even called. The last column of the
table above shows the minimum and maximum argument counts calculated
from the presented examples.

The actual argument names do not matter when tests are executed,
because only argument counts are of concern to Robot Framework. On the
other hand, if the `libdoc.py`_ tool is used for documenting the
library, arguments are shown in the documentation, in which case they
need to have meaningful names.

Getting keyword documentation
'''''''''''''''''''''''''''''

The final special method that dynamic libraries can implement is
:code:`get_keyword_documentation` (alias
:code:`getKeywordDocumentation`). It takes a keyword name as an
argument and, as the method name implies, returns its documentation as
a string. 

The returned documentation is used similarly as the keyword
documentation string with static libraries implemented with
Python. The main use case is getting keywords' documentations into a
library documentation generated with `libdoc.py`_. Additionally,
the first line of the documentation (until the first :code:`\\n`) is
shown in test logs.

Summary
'''''''

All special methods in the dynamic API are listed in the table
below. Method names are listed in the underscore format, but their
camelCase aliases function in exactly the same way.

.. table:: All special methods in the dynamic API
   :class: tabular

   ==========================  ================  ======================================================
              Name                 Arguments                       Purpose
   ==========================  ================  ======================================================
   get_keyword_names           \                 To return names of implemented keywords.
   run_keyword                 name, arguments   To execute the specified keyword with given arguments.
   get_keyword_arguments       name              To return keyword's argument specification. Optional.
   get_keyword_documentation   name              To return keyword's documentation. Optional.
   ==========================  ================  ======================================================

It is possible to write a formal interface specification in Java, as
below. However, remember that libraries *do not need* to implement
any explicit interface, because Robot Framework directly checks if the
library has the required :code:`get_keyword_names` and
:code:`run_keyword` methods. Additionally,
:code:`get_keyword_arguments` and :code:`get_keyword_documentation`
are completely optional.

.. sourcecode:: java

   public interface RobotFrameworkDynamicAPI {
   
       String[] getKeywordNames();

       Object runKeyword(String name, Object[] arguments);

       String[] getKeywordArguments(String name);

       String getKeywordDocumentation(String name);

   }


Hybrid library API
~~~~~~~~~~~~~~~~~~

The hybrid library API is, as its name implies, a hybrid between the
static API and the dynamic API. Just as with the dynamic API, it is
possible to implement a library using the hybrid API only as a class.

Getting keyword names
'''''''''''''''''''''

Keyword names are got in the exactly same way as with the dynamic
API. In practice, the library needs to have the
:code:`get_keyword_names` or :code:`getKeywordNames` method returning
a list of keyword names that the library implements.

Running keywords
''''''''''''''''

In the hybrid API, there is no :code:`run_keyword` method for executing
keywords. Instead, Robot Framework uses reflection to find methods
implementing keywords, similarly as with the static API. A library
using the hybrid API can either have those methods implemented
directly or, more importantly, it can handle them dynamically.

In Python, it is easy to handle missing methods dynamically with the
:code:`__getattr__` method. This special method is probably familiar
to most Python programmers and they can immediately understand the
following example. Others may find it easier to consult `Python Reference
Manual`__ first.

__ http://docs.python.org/ref/attribute-access.html

.. sourcecode:: python

   from somewhere import external_keyword

   class HybridExample:

       def get_keyword_names(self):
           return ['my_keyword', 'external_keyword']

       def my_keyword(self, arg):
           print "My Keyword called with '%s'" % arg

       def __getattr__(self, name):
           if name == 'external_keyword':
               return external_keyword
           raise AttributeError("Non-existing attribute '%s'" % name)

Note that :code:`__getattr__` does not execute the actual keyword like
:code:`run_keyword` does with the dynamic API. Instead, it only
returns a callable object that is then executed by Robot Framework.

Another point to be noted is that Robot Framework uses the same names that
are returned from :code:`get_keyword_names` for finding the methods
implementing them. Thus the names of the methods that are implemented in
the class itself must be returned in the same format as they are
defined. For example, the library above would not work correctly, if
:code:`get_keyword_names` returned :code:`My Keyword` instead of
:code:`my_keyword`.

The hybrid API is not very useful with Java, because it is not
possible to handle missing methods with it. Of course, it is possible
to implement all the methods in the library class, but that brings few
benefits compared to the static API.

Getting keyword arguments and documentation
'''''''''''''''''''''''''''''''''''''''''''

When this API is used, Robot Framework uses reflection to find the
methods implementing keywords, similarly as with the static API. After
getting a reference to the method, it searches for arguments and
documentation from it, in the same way as when using the static
API. Thus there is no need for special methods for getting arguments
and documentation like there is with the dynamic API.

Summary
'''''''

When implementing a test library in Python, the hybrid API has the same
dynamic capabilities as the actual dynamic API. A great benefit with it is
that there is no need to have special methods for getting keyword
arguments and documentation. It is also often practical that the only real
dynamic keywords need to be handled in :code:`__getattr__` and others
can be implemented directly in the main library class.

Because of the clear benefits and equal capabilities, the hybrid API
is in most cases a better alternative than the dynamic API when using
Python. One notable exception is implementing a library as a proxy for
an actual library implementation elsewhere, because then the actual
keyword must be executed elsewhere and the proxy can only pass forward
the keyword name and arguments.

A good example of using the hybrid API is Robot Framework's own
`Telnet library`_.


Using Robot Framework's internal modules
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Test libraries implemented with Python can use Robot Framework's
internal modules, for example, to get information about the executed
tests and the settings that are used. This powerful mechanism to
communicate with the framework should be used with care, though,
because all Robot Framework's APIs are not meant to be used by
externally and they might change radically between different framework
versions.

The safest API to use are methods implementing keywords in the
BuiltIn_ library. Changes to keywords are rare and they are always
done so that old usage is first deprecated. One of the most useful
methods is :code:`replace_variables` which allows accessing currently
available variables. The following example demonstrates how to get
:var:`${OUTPUT_DIR}` which is one of the many handy `automatic
variables`_. It is also possible to set new variables from libraries
using :code:`set_test_variable`, :code:`set_suite_variable` and
:code:`set_global_variable`.

.. sourcecode:: python

   import os.path
   from robot.libraries.BuiltIn import BuiltIn

   def do_something(argument):
       output = do_something_that_creates_a_lot_of_output(argument)
       outputdir = BuiltIn().replace_variables('${OUTPUTDIR}')
       path = os.path.join(outputdir, 'results.txt')
       f = open(path, 'w')
       f.write(output)
       f.close()
       print '*HTML* Output written to <a href="results.txt">results.txt</a>'

The only catch with using methods from :code:`BuiltIn` is that all
:code:`run_keyword` method variants must be handled specially. What
needs to be done is registering methods that use these methods to be *run
keywords* themselves using :code: :code:`register_run_keyword` method
in :code:`BuiltIn` module. This method's documentation explains why
this needs to be done and obviously also how to do it.

The plan is to document all the internal modules better so that it is
easier to decide which can be used and how they should be used. If you
are unsure is using some API safe, please send a question to either
user or developer `mailing list`_.
